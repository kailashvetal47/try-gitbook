---
ArticleId: e9e8ee45-1b8e-4044-9e6b-3feee1e45114
ArticleIndex: 126
Created: Dec 23, 2020 5:58 PM
URL: https://linuxconfig.org/linux-commands
Updated: Dec 23, 2020 7:32 PM
WebClipIndex: 126
author: Kailash Vetal
secret: true
slug: e9e8ee45-1b8e-4044-9e6b-3feee1e45114
title: Linux Commands - LinuxConfig.org
---
#  Linux Commands - LinuxConfig.org
## Introduction

Are you a beginner GNU/Linux user and wish to look beyond the usual window dragging and mouse clicking? This guide is intended for the absolute beginner users wishing to learn the basics of GNU/Linux command line. This tutorial intends to walk through basic Linux commands related to navigation, file and directory administration, software installation and basic system troubleshooting.

### What is the GNU/Linux Command Line

The chances are that whenever you hear somebody talking about the GNU/Linux operating system you also listen to them talking about command line or Linux commands. Run this command and execute this and that command! Right?

However, why? Why is it that the GNU/Linux operating system is almost always linked with commands and command line? The simple answer is that command line is an integral part of the GNU/Linux operating system, and as such it offers the user a possibility to perform tasks more efficiently, with better precision and most importantly with additional insight information about the entire execution process.

**Many GNU/Linux's beginner users associate the command line, and Linux commands with trepidation, high-level wizard magic skills and unnecessary overhead. Let's be honest with ourselves! No matter what excuse you might have for your aversion to GNU/Linux system and its command line, the cause is most likely linked to the lack of understanding and reluctance to learn.
Therefore, let's not blame the GNU/Linux system for our shortcomings! It is here to help whether you are a complete beginner or advanced level user. To what extent the system can help you does not depend on the depth of your wallet as this is the case with some other proprietary operating systems! The amount of help you receive from the GNU/Linux system is solely dependent on your willingness to learn and your determination.**

At this stage, I'm sure that the question you are asking yourself is: **Do I need to learn the GNU/Linux command line and the myriads of commands to use GNU/Linux operating system?** The quick answer is no! Any decent GNU/Linux operating system with GUI installed does not require the user to use the command line to perform basic and even advanced tasks.

The only reason why you might consider to learn the GNU/Linux command line is to improve your efficiency to get the most of the system and if the task ahead requires you to do so. Remember many GNU/Linux users go for years without even knowing what command line is! Not knowing the Linux command line is perfectly fine, and if the system does what you need there is no need to learn even the most basic commands.

No matter what flavour of GNU/Linux operating system you are using, whether it has Graphical User Interface or not, the command line is always present in some form. Hence, if you know the command line basics, you still feel at home regardless of the system in use. Command line, by use of the variety of commands, allows you to administer the system and perform even the most complex tasks on any the GNU/Linux system without GUI as well as remotely across the long distances seemingly making you feel you are sitting right in front of the computer.

However, to do so, one needs to possess at least the rudimentary understanding of the GNU/Linux command line and learn some basic usage of some of the commands it offers. Do not be afraid, as this is precisely what you are going to learn by reading this Linux commands tutorial.

### What are Linux Commands

Linux commands are the essence of the entire GNU/Linux operating system used to administer the entire system. You may not know it, but most of the applications you run within the graphical user interface are executing Linux commands for you in the background to accomplish the given task.

Letting the application to run Linux commands automatically for us has many obvious benefits. However, the disadvantage is that in many cases we are unable to customise the command execution to craft it towards the desired result. Furthermore, if something goes wrong, the user is most likely left in the dark without any hint on how to even begin to troubleshoot the issue.

Now you might be thinking: **Ok, that is all fine but [how many commands](https://forum.linuxconfig.org/t/how-do-i-list-all-linux-commands/) are there and should I learn all of them?** The amount of Linux commands available on your GNU/Linux system is irrelevant as the number is always different from system to system. However, if you insist on the exact number execute the following command in your terminal:

```
$ for i in ${PATH//:/ }; do ls $i; done | sort | uniq | wc -l

```

The number of commands available on your system will be different. The bottom line is that on average the GNU/Linux operating system may contain few thousands of commands which ultimately also answers our next question which is whether the user needs to learn all of them. Well, you may try, but this quest is destined for failure.

For this reason, the best approach is to start with the basics; the absolute must learn Linux commands to help you navigate the GNU/Linux filesystem and to perform the basic administration tasks. Once you accomplish this task and grow confident with the Linux command line, the rest comes naturally with the minimum effort simply by just using the GNU/Linux system. All you need is an open mind and determination.

**Ok, enough with this idle talk and let's get to it!** 

## Basic File-system and Navigation Linux Commands

### Command line arguments, options and parameters

Understanding the difference between Linux command line arguments, options and parameters is likely the most crucial part if one wishes ever to understand the GNU/Linux command line fully. Hence, do not skip this topic but instead make sure you understand it thoroughly before moving forward to the next section.

The best tool to explain the difference between Linux command line arguments, options and parameters is the [ls command](https://linuxconfig.org/ls-command). Do not worry if you do not know the `ls` command yet as this command is in detail covered in later sections. [Open up terminal](https://linuxconfig.org/how-to-open-a-terminal-on-ubuntu-bionic-beaver-18-04-linux) and run the following command. Do not enter the `$`sign as this sign only serves a purpose to inform you that this is a command to be executed on the command line and is to be executed as a regular non-privileged user:

```
$ ls

```

After you typed the above command and hit the ENTER key, the command lists all files and directories within your current directory. For now, disregard the output of the command and note that this command consists of a single argument which is the command `ls` itself. We refer to this argument as the argument `0`. Next, try this command:

```
$ ls -a

```

The above command consists of two arguments. The first argument referred to as argument `0` is the `ls` command itself and the second argument numbered as `1` is the `ls` command's option `-a`.

The command options allow the user to modify the command output. Every Linux command has a different set of options. The command options are hard-coded into the command itself. As the name suggests, the command options are optional and do not require the user to use them. In this case the `ls`command's option `-a` instructs the command to print also hidden files or directories located within our directory.

While still in your home directory, run the following command:

```
$ ls -l .bashrc

```

If you follow, you already know that the above command consists of three arguments. First, there is the `0` argument of the command itself. The second argument, more precisely, the argument `1` is the `ls` command's option `-l` which instructs the `ls` command to produce long listing output giving the user more information about one or more files. Lastly, the third argument number `2` is a parameter supplied to the `ls` command telling the command to act only on a single file named `.bashrc`.

A parameter is a command line argument that provides additional information to either the command itself or one or more of its options. Depending on what command you are executing you can supply one or more options or parameters. Consider the following example:

```
$ ls -l -h .bashrc .bash_history

```

In this case, our command consists of five arguments. There is the `ls` command, two options, namely they are `-l` and `-h` and lastly there are two file names as parameters, the `.bashrc` and `.bash_history` file.

The order in which you supply all arguments on the command line depends on the Linux command you are executing. However, the recommended and the universal rule is to supply all your required options after the command followed by all required parameters. For example, the below is also a valid command which produces the same output as the one above, however, this kind of command syntax should be avoided:

```
$ ls .bashrc -l .bash_history -h

```

Lastly, to shorten your command, thus make it more readable, most of the commands allow the user to combine multiple options into a single argument. Meaning that it is possible to combine the options `-l` and `-h` into a single argument as `-lh`. For example:

```
$ ls -lh .bashrc .bash_history

```

The following video summarises the entire section. By now you should have a clear understanding of what are command line arguments, options and parameters.

### File system navigation

This section covers yet another essential part of Linux command line which is the filesystem navigation. Over the years I have seen many users having a hard time to understand the GNU/Linux filesystem navigation as it dramatically differs from the usual `C:` or `D:` drives. In this section, you will also learn a first two Linux commands, which are the `cd` command and the `pwd` command.

Let us start with the following statement: **Forget about `C:` or `D:` drives you know from other proprietary operating systems.** This knowledge does not apply here and can only confuse you. The GNU/Linux filesystem allows access to any hard drive or partition from any directory within the entire filesystem. However, at this stage, we should not be concerned about that.

Perhaps the best analogy to describe the GNU/Linux filesystem is the one I have already used for my [Bash Scripting Tutorial](https://linuxconfig.org/bash-scripting-tutorial-for-beginners). Imagine the GNU/Linux filesystem as a multiple storey building. The so called root directory (building's entrance door) indicated by `/` provides the entry to the entire filesystem (building), hence giving access to all directories (levels/rooms) and files (people).

To navigate to room 1 on level 3 we first need to enter the main door `/`, then make our way to level 3 `level3/` and from there enter the `room1`. Hence, the **absolute path** to this particular room within a building is `/level3/room1`. From here, if we wish to visit room2 also on level3 we first need to leave our current location that is room1 by entering `../` and then include room's name `room2`. We took a **relative path** to room2 which in this case is `../room2`. We were already on level 3, so there was no need to leave the entire building and take absolute path via the main entrance `/level3/room2`. Confusing? Do not worry after few sessions with the GNU/Linux command line the knowledge sinks in and becomes a second nature to you.

Believe it or not, the GNU/Linux operating system provides all users with a compass to aid in filesystem navigation in the form of the `pwd` (**p**rint **w**orking **d**irectory) command. Every time you get lost merely enter the `pwd` command, and it will show you the path. Try it now. Open the terminal and type `pwd` followed by ENTER:

```
$ pwd

```

By default, your starting working directory is always your home directory. Every non-system user has its directory located within the `/home` directory. As illustrated on the above image the absolute path to the home directory of the user `linuxconfig` is `/home/linuxconfig`. If your system includes user "john", then the absolute path to this user's home directory is `/home/john`.

At this stage, we should know how to enter commands on the command line, and we also know how to obtain our current location within the filesystem. It is time to start moving around. To do just that, we use the `cd` (**c**hange **d**irectory) command. The `cd` command allows the user to navigate to any directory available on the filesystem under the condition that the user has proper access permissions.

Try it by executing the following commands and do not be afraid to experiment. Do not forget about your personal compass, the `pwd` command, to instantly tell you your current location. Please ensure to replace the below `linuxconfig` user with your own username:

```
$ cd /home
$ cd linuxconfig
$ cd /
$ cd home/linuxconfig
$ cd ../linuxconfig
$ cd ../../etc
$ cd /home/linuxconfig

```

Except for Line 5 and Line 6 the above commands should be self-explanatory. On Line 5 we have used shortcut `../` to move up to a parent directory of the `linuxconfig` directory. On Line 6 we have moved two directories up and eventually navigated to the `etc` directory.

Traversing the GNU/Linux filesystem and understanding the difference between the absolute and relative path is not an easy topic for any beginner. Before moving forward make sure that you feel comfortable with the `cd` Linux command and the navigation between directories, as this knowledge is going to serve you well in the upcoming sections.

### Listing a directory content

At this point, you should be comfortable with filesystem navigation using the `cd` command, and you also possess a basic understanding of the GNU/Linux command line in general including the command line arguments, options and parameters. So far we have learned how to navigate to any directory but have not learned how to list directory content yet. Listing a directory content is the main topic for this section.

The tool to be used to list the content of any directory is the `ls` command. Try it now. Open the terminal and enter the `ls` command within your home directory on its own without any options or parameters:

```
$ ls

```

By executing the `ls` command without any options or parameters, the command lists the content of the current working directory. Many modern terminals provide the user with additional information by colouring directories as blue, regular files as white and executable files with green colour. Be aware that you won't find this kind of luxury on many terminals, and for this reason, we need to learn how to distinguish between the various types of directory content items manually using the `ls` command.

As we have already learned in previous sections, it is possible to modify the command's output by using its pre-programmed options. In this case the `-l` option also known as long listing adds more information to the default `ls` output:

```
$ ls -l

```

By using the `-l` option, the `ls` command provides the user with extra information such as the permissions, user or group ownership, file size and modification time.

Another common `ls` command option is `-a` which lists all as wells as the hidden files or directories within the directory. Any file or directory that has its name prefixed with `.` is hidden thus not included as part of the default `ls` command output.

```
$ ls -a

```

Many of the `ls` command's options have meaning only in combination with some other options. For example, to show the file size of any selected file the user can supply the `ls` commands with the `-l` option and with the actual file name in question as a parameter. Consider the following `ls` command example to show the size of the `image.jpg` file:

```
$ ls -l image.jpg

```

By default, the `ls` command displays the files size in bytes, that is unless the `-h` ( human readable ) option is supplied. Note that the `-h` option has no meaning unless provided in combination with the `-l` option.

At this point, it is important to note that by using parameters users can list any directory or find information about any file on the entire filesystem without leaving their home directory. To do so simply supply **absolute** or **relative** path to a file or directory you wish to list more information about as a **parameter** to the `ls` command. Try the following `ls` command examples:

```
$ ls /etc/systemd
$ ls -l ../
$ ls -lh /etc/services

```

### Creating a directory

The purpose of directories is to keep the filesystem, hence our and system files organised. In this section, you learn how to create directories using the `mkdir` command on the GNU/Linux command line.

Creating a directory on the GNU/Linux system is as simple as executing the `mkdir` command while stating the desired directly name as an argument. Try it now. Open the terminal and create a new directory named, e.g. `dir1` in your home directory.

```
$ mkdir dir1

```

Next, use the `ls` command to list the content of your current working directory, and if the directory was created correctly, you should see it in the command output.

Same as creating the directory inside your current working directory you can also create a directory anywhere on the filesystem, given that you hold proper permissions to do so. Let's now create a new directory called `example` within the `/tmp` directory.

There are now two ways how to approach this task. First, we could navigate to `/tmp` using the `cd` command and once in the directory execute the `mkdir` command followed by the new directory name.

The other solution is to create the directory by merely prefixing the new directory name with the correct absolute or relative path of the directory where our new `example` directory is to be created. Hence no need to use the `cd` command to move to the `/tmp/` directory prior the `mkdir` command is executed:

```
$ mkdir /tmp/example

```

There is not much to learn regarding the `mkdir` command. As long as you understand the difference between absolute and relative path as explained earlier, you are fine. There is only one other common option used in combination with the `mkdir` command, and that is the `-p` option.

Let's say you wish to create a new directory `dir2` within your existing directory `dir1` as well as create new `dir3` within `dir2`. The first solution would be first to create `dir2` followed by execution of second `mkdir` command to create `dir3` within the `dir2` directory. However, using the `-p` option, this can be achieved by a single `mkdir` command execution:

```
$ mkdir -p dir1/dir2/dir3

```

### Creating files and reading the file content

The GNU/Linux system stores majority of information about settings, configuration as well as data such as logs in the form of plain ASCII text files. For this reason, it is essential for any user to have at least a basic understanding of text file manipulation.

In this section, you learn how to create files, read the file content and how to edit a text file using a simple command line based text file editor.

Let's start by creating an empty file named `file1` within our home directory. To do this, we use the `touch` command. Open your terminal and enter the following Linux command:

```
$ touch file1

```

That is all! You have now successfully created a new file called `file1` within your home directory. Execute the `ls` command now, and you should see this new file to sit in your home directory. Perhaps, you may have noticed that we have created a file without an extension such as `.txt` or `.exe`. Note, the file extension on GNU/Linux systems mostly does not have any meaning apart from the fact, that upon the execution of the `ls` command to list all files and directories it is immediately evident that a file with an extension `.txt` is plausibly an ASCII text file and a file with `.png` is likely to be an image file.

At this point, it is important to point out that there are many ways on how to create a file on a GNU/Linux operating system. In reality, it is scarce that you need to create an empty file as we have done previously. In fact, the primary purpose of the touch command is not to create files but rather manipulate with file timestamps, which is a tale for another time.

Since the prime purpose of files is to store data, we are going to do just that. Let's use a text file editor called `nano` to create a new file named `todo-list.txt` containing some arbitrary text. Start by executing the following command:

```
$ nano todo-list.txt

```

Once you execute the `nano` command, the nano editor opens and lets you edit the content of the new `todo-list.txt` file. While in the `nano` editor perform any modifications to the file content as required.

Once ready, press `CTRL+o` followed by the `ENTER` key to save the file. At this point, the new `todo-list.txt` file is created. To exit from the `nano` editor press the `CTRL+x` key combination as illustrated on the below images: You can continue editing any existing text file by specifying the file name as a parameter to the `nano` text editor command.

So far we learned how to create a file and how to edit existing or new text file using a command line text editor. What we have not covered yet is how to read the content of the text file. Well, honestly, there is not much to it! You can read the content of any file by using the `cat` GNU/Linux command.

Try it now. Execute the `cat` command and as a parameter supply the name of the file you wish to examine. For example:

```
$ cat todo-list.txt

```

Before we mark this section as "Done and Dusted", there is one more command you should familiarize yourself with. This command is called `file`.

Remember, previously, we talked about that it is not essential to suffix file names with extensions. Well if this is the case, how we are going to know what type of file is stored in our home directory or anywhere on the GNU/Linux filesystem for that matter? This is where the `file` command becomes handy. The `file` command outputs the file type of any file supplied to it as a parameter. Try it now:

```
$ file todo-list.txt

```

### Rename or move files and directories

Another logical step is to learn how to rename or move files and directories. At this point, we have discussed how to create files or directories, but what about moving existing directory or file to another location? Well, you should be pleased to know that moving and renaming files or directories under the GNU/Linux system is in core essentially the same.

Renaming and moving files on the GNU/Linux filesystem is a straightforward task. All that is required is the `mv` command and the understanding of the absolute and relative path as previously covered in the above **File system navigation** section.

Consider the following example:

```
$ touch file1
$ mkdir dir1

```

Using the above `touch` and `mkdir` commands we have created a file named `file1` and directory `dir1`. The usage of the `touch` and `mkdir` commands have been already covered previously, hence the explanation should not be necessary.

The task ahead is to rename `file1` to `file2` and `dir1` to `dir2` by using the `mv` command. To do so we need to supply the `mv` command with the absolute or relative path of the file or directory we wish to rename as a first parameter. The second required parameter is the absolute or relative path of the file or directory we wish our file or directory to be renamed to:

```
$ mv file1 file2
$ mv dir1 dir2

```

The point to understand here is that GNU/Linux does not have an explicit command to rename files. Instead, the `mv` (short for move) command is used to move file or directory from one location to another while changing their name in the process. Consider the following example:

```
$ mv file2 /tmp/file3
$ mv dir2 /tmp/dir2

```

The first command has moved `file2` into directory `/tmp/` and renamed it to `file3`. The second command has moved `dir2` into `/tmp/` and since we have supplied the same destination directory name the directory name remains the same.

Hence, the second command is essentially only moving the source `dir2` into destination directory `/tmp/` thus the second parameter stating the new directory name is not required and could be executed simply as:

```
$ mv dir2 /tmp/

```

It is essential to understand the above `mv` command, since the `mv` command has also an ability to accept multiple parameters. Meaning, it is possible to move multiple directories and/or files at the same time by executing the single `mv` command:

```
$ mkdir dir4 dir5
$ touch file4 file5
$ mv file4 dir4 file5 dir5 /tmp
```

The above `mv` command have moved multiple files and directories into the new location: the `/tmp` directory. It is important to point out here that no matter how many source files or directories you are going to supply to the `mv` command as parameters the last supplied parameter is treated as a destination.

Before we move to another topic it is important to mention one, possibly damaging fact about the `mv` command. The below image demonstrates the `mv` command in action as described in this section:

### Copy files and Directories

In the previous section, we discussed how to move files and directories from one location to the other by the use of the `mv` GNU/Linux command. This section covers a similar topic on how to make a copy of files and directories by using the `cp` command.

Most of the knowledge gathered from the previous section is going to help us to learn the `cp` GNU/Linux command as the syntax for both `mv` and `cp` commands is very similar. The main difference is that instead of moving the files or directory the `cp` command creates an exact copy of the source file or directory.

As it is with the `mv` command the `cp` command requires to be supplied with at least two parameters. The first parameter is the source file or directory and the second parameter is the destination file or directory.

Let's start with a simple example of creating a copy of the file located in our home directory. First, we use the `touch` command to create a new file named `file1`, and then we make an exact copy of it called `file2`:

```
$ touch file1
$ cp file1 file2

```

The rather obvious rule here is that the source and destination parameters supplied to the `cp` command cannot be the same:

```
$ cp file1 file1
cp: 'file1' and 'file1' are the same file

```

The only way to supply an exactly same file name for both source and destination parameter is to copy the file into a different directory using either the absolute or relative path. The following `cp` command example makes a copy of `file1` to the directory `/tmp`:

```
$ cp file1 /tmp/file1

```

However, if you have no intention to change the file name, there is no need to supply the file name as a destination parameter at all. Hence, the above command can be abbreviated as:

```
$ cp file1 /tmp/

```

You can use the same `cp` command syntax to make also a copy of a directory. However, there is one significant difference, and that is that to copy a directory we need to use the `-r` ( recursive ) `cp` command option. Consider the following example:

```
$ mkdir dir1
$ cp dir1 /tmp/
cp: -r not specified; omitting directory 'dir1'
$ cp -r dir1 /tmp

```

As it is the case also with the GNU/Linux `mv` command, the `cp` command also accepts multiple parameters. Meaning, that it is possible to copy multiple files and directories at the same time by execution of the single `cp` command.

The rule is that the last parameter must be a directory. Examine the following example, where we first create another sample directory and file. Next, we copy this directory along with other two files to the `/tmp/` directory:

```
$ mkdir dir2
$ touch file1 file2
$ cp -r dir2/ file1 file2 /tmp/

```

The below image demonstrates the `cp` command in action as described in this section:

### Remove files and Directories

At this stage, you should be quite confident with the Linux command line basics. You may also have noticed a pattern in which commands are used. You should know how to create, move and rename any file or directory. However, without knowing how to remove files or directories, your filesystem fills up, hence the ability to store more data will be lost.

Two commands will be covered in this section. The first command is `rmdir` and the second command is `rm`. When looking at the names of both the `rmdir` and `rm` commands you may quickly conclude that the command `rmdir` is used to remove directories and the latter command `rm` is used to delete files and for the most part you are right. Let's start by looking at the `rmdir` command first.

For our experiments, we will be using the following directory structure containing multiple sub-directories and files. Our goal is to learn how to use `rmdir` and `rm` commands to remove all files and directories: As it is with any GNU/Linux commands you have already learned, the `rmdir` command also accepts multiple arguments. For example, to remove `dir4` all we need to do is to supply the `rmdir` command directory with the name of the directory we wish to remove as a parameter:

```
$ rmdir my_files/dir4/

```

Simple right? Let's now remove next directory say `dir1`:

```
$ rmdir my_files/dir1
rmdir: failed to remove 'my_files/dir1': Directory not empty

```

As you can see, the above `rmdir` command failed to remove the `dir1` directory. The primary job of the `rmdir` is to remove directories, and since the directory `dir1` contains files, the `rmdir` command omitted this directory with an error message complaining that this directory is not empty.

The logic is sound! The only way to remove non-empty directory is to use `rmdir`'s rather long command line option `--ignore-fail-on-non-empty`. However, at this point it is much easier to use the `rm` command. The `rm` command is with a correct combination of options capable to remove any number of files and directories whether the directory is empty or populated with any number of files and sub-directories.

First, let's test `rm` to remove the file called `my_file.txt`:

```
$ rm my_files/my_file.txt

```

To remove directory with `rm` we need to use the `-r` option combination. The option `-r` stands for recursive, meaning that the command will remove any directory as well as its content. The following command will remove the entire `my_files/dir1` directory including any file or sub-directory:

```
$ rm -r my_files/dir1/

```

Using the `rm` command is quite straight forward. As many other Linux commands it accepts multiple parameters thus can easily remove single or any number of files and directories.

### Search for files or directories

At this point, you should be quite comfortable with file-system navigation and file/directory management. Before we move to the next section dedicated to basic GNU/Linux system administration commands, we should discuss how to look for files in case such a need arises. There are two main Linux commands which allow a user to search for files. Namely, it is the `locate` command and the `find` command.

The `find` command is a powerful tool hence it can be a little bit overwhelming to use, especially when it comes to beginners. For this reason, we cover the `locate` command only as it is much easier to use.

The basic usage of the `locate` Linux command is quite simple. Type `locate` followed by the file or directory name as a parameter. For example, let's search for a file called `issue`:

```
$ locate issue

```

The above command produces a list of files or directories within the entire file-system containing the string `issue` anywhere within the file or directory name. Depending on what you are searching for this list can grow to a substantial size.

Therefore, searching for an exact filename match is likely to produce an output we are more inclined to find accommodating. To do so, we need to use [regular expressions](https://linuxconfig.org/understanding-regular-expressions) and the `locate`'s command line option `-r`.

Regular expressions are well beyond the scope of this tutorial. For now, we only need to know, that to search for an exact filename or directory name we need to surround the string with `/` and `$`. For example:

```
$ locate -r /issue$

```

Before you promote yourself into a rank of the `locate` Linux command master, let's briefly discuss how the `locate` command operates. The `locate` command is extremely fast in search, because it merely consults existing pre-build database index file updated once a day with use of the `updatedb` command.

The disadvantage is that the `locate` command would not pick up any files or directories created since the last `updatedb` command was executed. However, to include any new files, the users have an option to run the `updatedb` command manually as illustrated below:

```
$ sudo updatedb

```

## Basic Administration Linux Commands

### Executing commands with Administrative Privileges

Most of the Linux commands you will run will be executed without administrative privileges. As a matter of fact, executing commands with administrative privileges is recommended only in the case that the task ahead requires it. Following this simple rule will contribute to overall system integrity and will allow the user to avoid costly and unnecessary mistakes while interacting with the Linux command line.

However, it is hard to imagine to avoid executing Linux commands with administrative privileges completely. Administrative privileges are required for new software installation, a configuration of core system services and more. This is where the `sudo` Linux command becomes handy. Prefixing any Linux command with `sudo` will ensure that the command is executed with administrative a.k.a root privileges. Try it yourself:

```
$ sudo whoami
$ whoami

```

By default 5 minutes are given to a `sudo` user to enter privileged commands repeatedly using the `sudo` command without password after the first successful authentication.

### Software Installation

The default installation of your GNU/Linux system can be and very often is customized to include additional software to suit your needs. If there is a difference between various GNU/Linux distributions, it is the way on how the software is installed. The software is delivered in the form of packages available from relevant distribution package repository.

There are two main branches of GNU/Linux distributions when it comes to software package management.

Namely, they are **DEB** and **RPM**. The first branch is using `apt` and the second branch is using the `yum` command to install software. Of course, there are many other auxiliary commands to help with software installation or maintenance, but the basics are explained below.

First, we start searching for a package name of the software we wish to install. Let's say that we need to install some sort of a torrent client so we are able to download torrent files. First, we search for a package name:

```
DEB GNU/LINUX SYSTEMS:
$ apt search torrent client
RPM GNU/LINUX SYSTEMS:
$ yum search torrent client

```

The above commands will produce a list of package names and their relevant description. Read the description column and select a package from the left column which you would like to install. Once you have selected the package you wish to install execute again a relevant package management command to install the package.

Let's say the package we wish to install is called `bittorrent`. To start the installation our command must be executed with administrative privileges as described in the previous section. When prompted, type `y` to perform the installation:

```
DEB GNU/LINUX SYSTEMS:
$ sudo apt install bittorrent
RPM GNU/LINUX SYSTEMS:
$ sudo yum install bittorrent

```

### Checking for disk space usage

In this section, you will learn how to check a directory and file size as well as how to obtain information about your current disk space usage. The first Linux command we are going to cover in this section is the `df` command. The command name `df` is an abbreviation of the words **d**isk **f**ree.

By executing the `df` command without any parameters, the command returns information about used and available disk space for all partitions accessible in kilobytes. The default `df` command output prints the disk usage information in kilobytes. However, this behavior can be overwritten by using the `-h` option:

```
$ df -h 

```

To check for free disk space of any desired directory simply add the full path to this directory as a parameter to the `df` command. Example:

```
$ df -h /home

```

Now that we have learned how to check for free disk space it is also important to know how to retrieve information about a file and directory size.

To get information about the file size in the human-readable format, we can use the above covered `ls` command with the combination of `-l` ( long-listing ) and `-h` ( human-readable ) options and the full or relative path to the file in question. For example, the below `ls` command will return the size of the file called `swapfile` located within the root directory `/`:

```
$ ls -lh /swapfile

```

Same as checking for a file size we can use the `du` command to check for the directory size. By default the `du` command when supplied with directory parameter will display the size of all directories within:

```
$ du -h /home/

```

To obtain a total size summary of a single directory use the `-s` option. Once again, as in all the above examples in this section, we are interested in human-readable output hence using the `-h` option:

```
$ du -sh /home/

```

### File and directory compression

In this section, we will discuss few ways of how to compress and decompress files on the GNU/Linux system. The first tools you will learn are the `tar` and `gzip` commands. The `tar` command is mostly used to combine the entire directory into a single file and optionally applying compression in the process if necessary.

The following `tar` command example will combine the entire directory `my_dir` into a single file called `my_dir.tar`:

```
$ tar cf my_dir.tar my_dir

```

To further compress the resulting file we can use the `gzip` command to produce a compressed file called `my_dir.tar.gz`:

```
$ gzip my_dir.tar

```

However, most of the time we need to compress the directory anyway, therefore it is possible to compress the directory combining both the `tar` and `gzip` tools as an alternative to above commands:

```
$ tar cxf my_dir.tar my_dir

```

The files produced by the combination of the `tar` and `gzip` commands are called **gzip tarballs** or simply **tarballs**.

To unpack any tarball we can simply revert the process, but instead of the `gzip` we will use the `gunzip` command. For example, to decompress the gzip tarball `my_dir.tar.gz` we can use the `gunzip` command:

```
$ gunzip my_dir.tar.gz

```

The above command will produce our original file `my_dir.tar` containing the `my_dir` directory. Using the `tar` command we can further unpack this tarball to retrieve the original `my_dir` directory:

```
$ tar xf my_dir.tar

```

### Shutting down and rebooting

When it comes to shutting down and rebooting the GNU/Linux operating system there is only one command you need to learn, which does both, reboot and shutdown. This command is intuitively called `shutdown`.

Yes, it is true you can reboot your system with for example the `init 6` or `reboot` command, but learning the `shutdown` command gives you more power and options. Below there are a few examples of the `shutdown` command.

The first `shutdown` command example will reboot your system in one minute time:

```
$ sudo shutdown -r

```

To reboot your GNU/Linux system immediately execute:

```
$ sudo shutdown -r now

```

Shutting down your system using the `shutdown` command follows the same principle as shown by the above reboot commands. The following two examples show how to shutdown the system in one minute time, immediately and with 1.5 hour (90 minutes) delay:

```
$ sudo shutdown
$ sudo shutdown now
$ sudo shutdown +90

```

In case you have executed the delayed system shutdown you may cancel the shutdown process by:

```
$ sudo shutdown -c

```

## Advanced Linux Commands

### Troubleshooting Internet/Network connection

This section will introduce you to some basic networking skills. In particular, you will learn how to obtain an IP address of services required to establish a proper Internet connection and how to troubleshoot network connectivity and an Internet connection.

Let's get started by obtaining our local IP address by using the `ip` command. The `ip` command has a number of options which include the `address` or `a` option for short to display IP addresses assigned to all the available and enabled network interfaces:

```
$ ip a

```

The above command reveals the IP address currently used by the system. Please note that your network interface name may be different. In the next example, we obtain the IP address of your gateway. Once again we use the `ip` command but this time with the `r` ( route ) option:

```
$ ip r

```

Next piece of the puzzle is the DNS ( domain name server ) IP address. To check which DNS server is your system using to resolve hostnames to IP address simply check the content of the `/etc/resolv.conf` file using the `cat` command as explained earlier:

```
$ cat /etc/resolv.conf

```

Now that once we obtain the most basic network configuration information we can use it to troubleshoot many kinds of network connectivity issues such as, for example, the Internet connection. The best tool for this task is the `ping` command.

Using the `ping` command, we can test the connection to any IP address or host. The `ping` command will send a packet to any desired host or IP address and inform us about the result. By default, the `ping` command will send an endless ping to selected IP address or host. To interrupt a continuous `ping` press the `CTRL+C` key combination. Alternatively, use the `-c` option with the combination of the number indicating the packet count you wish to send. For example:

```
$ ping linuxconfig.org 
PING linuxconfig.org (104.24.11.18) 56(84) bytes of data.
64 bytes from 104.24.11.18 (104.24.11.18): icmp_seq=1 ttl=57 time=9.83 ms
64 bytes from 104.24.11.18 (104.24.11.18): icmp_seq=2 ttl=57 time=10.0 ms
64 bytes from 104.24.11.18 (104.24.11.18): icmp_seq=3 ttl=57 time=9.95 ms

--- linuxconfig.org ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2002ms
rtt min/avg/max/mdev = 9.833/9.933/10.008/0.073 ms

$ ping -c 2 8.8.4.4 
PING 8.8.4.4 (8.8.4.4) 56(84) bytes of data.
64 bytes from 8.8.4.4: icmp_seq=1 ttl=121 time=10.3 ms
64 bytes from 8.8.4.4: icmp_seq=2 ttl=121 time=10.4 ms

--- 8.8.4.4 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1001ms
rtt min/avg/max/mdev = 10.340/10.412/10.485/0.125 ms

```

In case you are experiencing any Internet connectivity issues you can troubleshoot the network connections by pinging all above IP addresses either starting from your local IP address or any public host. Using this strategy will help you narrow down the possible issue causing your network connection problems as illustrated below.

### Changing permissions and ownership

Every file or directory within the GNU/Linux filesystem can be owned by different users as well as various user groups. Furthermore, every file or directory can be set to conform to one or more permissions such as read, write and execute. The topic regarding file or directory permissions or ownership can cover a small book. Since we are interested in basics, here are some tips to get you started.

Let's begin by obtaining the actual information regarding file or directory permissions. To do so execute the already learned `ls` command with the `-l` option and a file or directory name as the parameter. For example:

```
$ ls -l dir/

```

The detailed information about the output is illustrated on the image below. Please take some time to digest the information before moving forward:  As already indicated by the above image, there are three permission types, **read**, **write** and **execute**. The following table lists all permission types along with their symbolic and octal representation:

The tool to change file or directory permissions on the GNU/Linux file system is `chmod`. There are two ways on how to change file or directory permissions using the `chmod` command, namely, it is by octal or symbolic representation. From these two, the best approach is the one which you find easiest to remember and use.

The following example shows how to use the `chmod` command with both, octal and symbolic representation to change the `dir` directory permissions to the following:

The following two `chmod` linux commands using octal and symbolic permissions representation are interchangeable and will change the `dir` directory permissions as per the above requirements:

```
OCTAL:
$ chmod 760 dir
SYMBOLIC:
$ chmod u=rwx,g=rw,o= dir

```

The last tool to be covered in this section is the `chown` command. The `chown` command allows the user to change a file or directory ownership. Each file or directory has two types of ownership. Namely, these are the user and group ownership.

To change the ownership by using the `chown` command is a rather straightforward procedure. The generic rule of changing the file or directory ownership is to supply the `chown` command with two parameters. The first parameter supplied contains the username and the group name we wish this file or directory to be owned by separated by `.` and the second parameter representing the file or directory name in question.

The following `chown` Linux command example will change the file named `file.txt` to be owned by the user `lubos` and by all users belonging to the group `linuxconfig`:

```
$ chown lubos.linuxconfig file.txt

```

The following image is a quick summary of what has been discussed in this section:

### Check system's kernel version

There are times when you need to troubleshoot your GNU/Linux box, hence you need to obtain information about your currently running kernel a.k.a the Linux.

Using the `uname` command with a combination of `-a` will output detailed information about your kernel version and architecture:

```
$ uname -a

```

## Conclusion

That is all folks! But, do not get the length of this article to fool you into thinking that there is nothing else to learn. On the contrary, this article barely scratches the surface, as the aim was to only introduce the reader to some basic GNU/Linux command line techniques.

Please provide feedback below to help me improve this article. If you have any further question or need additional help, please visit the LinuxConfig [forum](https://forum.linuxconfig.org/).

What should you learn next? Well, keep experimenting with the basics and try to add new Linux commands to your repertoire daily. Practice makes perfect!

Once you are comfortable with basic Linux commands, consider my [Bash Scripting Tutorial](https://linuxconfig.org/bash-scripting-tutorial-for-beginners) for beginners to discover how to automate tasks using Linux commands with the combination of shell scripting.
